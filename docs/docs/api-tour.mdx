---
meta:
  title: API Tour
  description: Isn't this awesome?
  toc: true
---

# earthstar API tour

## Table of contents

## Introduction

`earthstar` is a reference implementation of Earthstar written in Typescript. You can use it to add Earthstar functionality to programs running on servers, browsers, or the command line.

It can be imported via URL into a browser:

```
<script type="module">
  import * as Earthstar from "https://cdn.earthstar-project.org/earthstar.bundle.js";
</script>
```

Or Deno:

```
import * as Earthstar from "https://deno.land/x/stone-soup/mod.ts";
```

or installed with NPM:

```
npm install earthstar
```

To integrate Earthstar into your program, your application will probably need a single instance of Earthstar's `Peer` class, which manages many shares and is responsible for synchronising them.

<img src="/api-tour/application.svg" class="h-72"/>

Nearly all of Earthstar's classes can be configured to suit your specific use-case, e.g. a `StorageAsync` can be configured to persist data to IndexedDB if you're building a browser app.

## Peer

<img src="/api-tour/peer.svg" class="h-60"/>

A `Peer` is responsible for managing many `StorageAsync`, and synchronising them across different transports. [Complete API documentation here.](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/Peer)

```typescript
const myPeer = new Peer();

myPeer.workspaces();
// [] - Nothing here yet!
// Learn how to add storages in the StorageAsync section.
```

## StorageAsync

![](/api-tour/replica.svg)

A local replica of a share's documents. Provides operations for querying and setting documents. [Complete API documentation here.](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/StorageAsync)

```typescript
import { StorageAsync, ValidatorEs4, StorageDriverMemory } from "earthstar";

// Construct a storage
const myStorage = new StorageAsync(
  // Needs a share address
  `+myshare.a8puorlpz1`,
  // At least one validator
  [ValidatorEs4],
  // And a driver to teach it how to read and write documents
  StorageDriverMemory
);

// Query for documents
const txtResults = myStorage.query({
  filter: {
    pathEndsWith: ".txt"
  }
});

// Set a document
await myStorage.set(myKeypair, {
  format: "es.4",
  path: "notes/ink.txt",
  content: "Don't forget to get some new ink."
});

```

## Storage drivers

<img src="/api-tour/storage-driver.svg" class="h-48"/>

Earthstar can be used on in browsers, on servers, or on the command line. There's no single way to persist data in all these environments, which is why `StorageAsync` is able to use different `StorageDrivers` suited to the environment its being used in.

Built-in Universal drivers:

- `StorageDriverMemory` (no persistence)

Web platform drivers:

- `StorageDriverLocalStorage`
- `StorageDriverIndexedDB`

It's possible to create your own storage drivers which conform to `IStorage`. [See the details here.](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/IStorageDriverAsync)

## Validators

<img src="/api-tour/validator.svg" class="h-48"/>

Earthstar shares are able to store documents of different formats. But most of the time, you'll want to use the built-in one from this library: `es.4`. As such, Earthstar currenly only offers one format validator: `FormatValidatorEs4` ([API documentation here.](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/FormatValidatorEs4))

Every time a new document is ingested by a `StorageAsync` it is checked by a validator.  In the case of `FormatValidatorEs4`, it checks whether a document's signature matches its  author, space address, and content.

It's possible to write your own validator which adheres to [`IFormatValidator`](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/src/format-validators/format-validator-types.ts/~/IFormatValidator).

## Identity

<img src="/api-tour/identity.svg" className="h-36" />

An identity is a keypair containing a public address and a secret. This keypair is used to sign documents whenever they're written. The public address can be freely distributed, but the secret should be, well, secret. [API docs here](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/AuthorKeypair).

You can generate identities using [Crypto](#crypto).

Note that documents are not *encrypted* (yet), only *signed*.  This means we can verify that the document has not been tampered with on its journey to you, making it possible for syncing to hop across several peers without worrying about them messing with your data.  They can still *read* your data.

Technically speaking, these are ed25519 keypairs encoded in base32.

## Query

<img src="/api-tour/query.svg" class="h-36"/>

Used to describe a document query. Used with `StorageAsync.query` and `QueryFollower`. [Full API details here](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/Query).

## Doc

<img src="/api-tour/doc.svg" class="h-36"/>

Represents some cryptographically-signed user data. The contents of a `Doc` can only be changed via `StorageAsync`. A document cannot be moved from one share to another. [Full API documentation here](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/Doc).

## Crypto

<img src="/api-tour/crypto.svg" class="h-40"/>

`Crypto` ([full API docs](https://doc.deno.land/https://deno.land/x/stone_soup@v8.0.0/mod.ts/~/Crypto)) is used internally for signing and verifying documents using [ed25519](https://ed25519.cr.yp.to). In most cases, you will want to use it to generate new identity keypairs:

```typescript
const keypair = Crypto.generateAuthorKeypair("suzy");

console.log(keypair);
/*
  {
    "address":"@suzy.bv3cclqhvnbn4fwjur7u4nimm4cznbzigqyihlfwi6acck5b4q54q",
    "secret":"bxrishindifrczhm5riqd4mozx4o5htksqthd64yph4rlfs6ej53n"
  }
*/
```

## setGlobalCryptoDriver

Because ed25519 is not part of any JS standard library (or WebCrypto API), there are several third-party implementations, some of which are only available for certain runtimes.

To balance compatibility and performance, Earthstar uses [noble/ed25519](https://github.com/paulmillr/noble-ed25519) by default. This works in browsers, Deno, and Node.

Earthstar exports a `setGlobalCrypto` function to change this:

```typescript
import { setGlobalCryptoDriver, CryptoDriverChloride } from "earthstar";

setGlobalCryptoDriver(CryptoDriverChloride);
```

## QueryFollower

<img src="/api-tour/query-follower.svg" class="h-40"/>

Listens to events from a `StorageAsync`, and if it matches the given query, sends an event to a [`SuperBus`](https://github.com/cinnamon-bun/superbus).

Here's a basic usage:

```typescript
const myMarkdownFollower = new QueryFollower(myStorage, {
  filter: {
    pathEndsWith: ".md",
  },
});

// Print every newly created / updated Markdown doc to the console
myJpgFollower.bus.on((event: LiveQueryEvent) => {
  if (event.kind === "success") {
    console.log("A markdown doc was updated or created!");
  }
});

// Start the follower.
myJpgFollower.hatch();
```

A `QueryFollower` must always be _hatched_ first. Hatching makes it catch up with all existing documents which match the query, after which it starts listening for new events.

When you're done with a `QueryFollower`, you should close it to stop callbacks from running:

```typescript
myJpgFollower.close();
```

## StorageCache

<img src="/api-tour/replica-cache.svg" class="h-44"/>

`StorageAsync` offers a strictly asynchronous interface to a share's contents. Sometimes a synchronous API would make life far easier, and `StorageCache` does its best to provide that.

`StorageCache` offers a synchronous API for fetching documents by storing queried documents in an internal cache.

When you first query a document, there is no result. But StorageCache can be subscribed to for updates, at which point you return to the cache and get an instant result:

```typescript
import { StorageCache } from "earthstar";

const cache = new StorageCache(myStorage);

const myQuery = { filter: { pathStartsWith: "/about/" } };

let aboutDocs = cache.queryDocs(myQuery); // This will be an empty list.

cache.onCacheUpdated(() => {
  // Trigger a re-querying of the cache!
  aboutDocs = cache.queryDocs(myQuery); // Now there should be something in there.
});
```

`StorageCache` has an optional TTL (time-to-live) option which can be provided to its constructor:

```typescript
const cache = new StorageCache(myStorage, 2000); // ms, 1000 by default
```

When you fetch an expired result from the cache, StorageCache will then return the latest result from its backing storage.
