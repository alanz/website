---
meta:
  title: earthstar API
  description: Isn't this awesome?
headers:
  Cache-Control: no-cache
---

# earthstar API

`earthstar` is a reference implementation of Earthstar written in Typescript. You can use it to add Earthstar functionality to programs running on servers, browsers, or the command line.

It can be imported via URL in the browser, or Deno:

```
import * as Earthstar from "https://esm.sh/earthstar";
```

or installed with NPM:

```
npm install earthstar
```

To integrate Earthstar into your program, your application will probably need a single instance of Earthstar's `Peer` class, which manages many commons and is responsible for synchronising them.

![](/api-images/outline.jpg)

Nearly all of Earthstar's classes can be configured to suit your specific use-case, e.g. a `StorageAsync` can be configured to persist data to IndexedDB if you're building a browser app.

## `Peer`

<details>
<summary>Type declaration</summary>
```typescript
interface Peer {
  // TODO: oops, or should we have storage IDs instead of peer IDs?
  peerId: PeerId;

hasWorkspace(address: string): boolean;
workspaces(): string[];
storages(): IStorageAsync[];
size(): number;
getStorage(address: string): IStorageAsync | undefined;

// setters
addStorage(storage: IStorageAsync): Promise<void>;
removeStorageByWorkspace(address: string): Promise<void>;
removeStorage(storage: IStorageAsync): Promise<void>;
}

````
</details>

![](/api-images/peer.jpg)

A `Peer` is responsible for managing many `StorageAsync`, and synchronising them across different transports.

```typescript
const myPeer = new Peer();

myPeer.workspaces();
// [] - Nothing here yet!
// Learn how to add storages in the StorageAsync section.
```

## `StorageAsync`

<details>
<summary>Type Declaration</summary>
```typescript
interface IStorageAsync {
  storageId: StorageId;
  workspace: WorkspaceAddress;
  formatValidator: IFormatValidator;
  storageDriver: IStorageDriverAsync;
  bus: Superbus<StorageBusChannel>;

  //--------------------------------------------------
  // LIFECYCLE

  isClosed(): boolean;
  close(erase: boolean): Promise<void>;

  //--------------------------------------------------
  // GET

  // this one is synchronous
  getMaxLocalIndex(): number;

  // these should all return frozen docs
  getDocsAfterLocalIndex(
    historyMode: HistoryMode,
    startAfter: LocalIndex,
    limit?: number
  ): Promise<Doc[]>;
  getAllDocs(): Promise<Doc[]>;
  getLatestDocs(): Promise<Doc[]>;
  getAllDocsAtPath(path: Path): Promise<Doc[]>;
  getLatestDocAtPath(path: Path): Promise<Doc | undefined>;

  queryDocs(query?: Query): Promise<Doc[]>;

  //    queryPaths(query?: Query): Path[];
  //    queryAuthors(query?: Query): AuthorAddress[];

  //--------------------------------------------------
  // SET

  set(keypair: AuthorKeypair, docToSet: DocToSet): Promise<IngestEvent>;

  // this should freeze the incoming doc if needed
  ingest(doc: Doc): Promise<IngestEvent>;

  // Overwrite every doc from this author, including history versions, with an empty doc.
  overwriteAllDocsByAuthor(
    keypair: AuthorKeypair
  ): Promise<number | ValidationError>;
}
```
</details>

![](/api-images/storage.jpg)

A local replica of a commons' documents. Provides operations for querying and setting documents.

```typescript
import { StorageAsync, ValidatorEs4, StorageDriverMemory } from "earthstar";

// Construct a storage
const myStorage = new StorageAsync(
  // Needs a commons address
  `+myCommons.a8puorlpz1`,
  // At least one validator
  [ValidatorEs4],
  // And a driver to teach it how to read and write documents
  StorageDriverMemory
);

// Query for documents
const txtResults = myStorage.query({
  filter: {
    pathEndsWith: ".txt"
  }
});

// Set a document
await myStorage.set(myKeypair, {
  format: "es.4",
  path: "notes/ink.txt",
  content: "Don't forget to get some new ink."
});

```

## Storage drivers

![](/api-images/storagedriver.jpg)

Earthstar can be used on in browsers, on servers, or on the command line. There's no single way to persist data in all these environments, which is why `StorageAsync` is able to use different `StorageDrivers` suited to the environment its being used in.

Built-in Universal drivers:

- `StorageDriverMemory` (no persistence)

Web platform drivers:

- `StorageDriverLocalStorage`
- `StorageDriverIndexedDB`

It's possible to create your own storage drivers which conform to `IStorage`.

## Validators

![](/api-images/validator.jpg)

Earthstar commons are able to store documents of different formats. But most of the time, you'll want to use the built-in one from this library: `es.4`. As such, Earthstar currenly only offers one format validator: `ValidatorEs4`.

Every time a new document is ingested by a `StorageAsync` it is checked by a validator.  In the case of `ValidatorEs4`, it checks whether a document's signature matches its  author, space address, and content.

## `Query`

<details>
<summary>Type declaration</summary>
```typescript
export interface Query {
  // for each property, the first option is the default if it's omitted

// this is in the order that processing happens:

// first, limit to latest docs or all docs
historyMode?: HistoryMode;

// then iterate in this order
// "path ASC" is actually "path ASC then break ties with timestamp DESC"
// "path DESC" is the reverse of that
orderBy?: "path ASC" | "path DESC" | "localIndex ASC" | "localIndex DESC";

// start iterating immediately after this item (e.g. get items which are > startAfter)
startAfter?: {
// only when ordering by localIndex
localIndex?: number;
// only when ordering by path
path?: string;
};

// then apply filters, if any
filter?: QueryFilter;

// stop iterating after this number of docs
limit?: number;
// TODO: limitBytes
}

````

</details>

![](/api-images/query.jpg)

Used to describe a document query. Used with `StorageAsync.query` and `QueryFollower`.

## `Doc`

![](/api-images/doc.jpg)

<details>
<summary>Type declaration</summary>
```typescript
interface Doc {
    format: string,
    author: string,
    content: string,
    contentHash: string,
    deleteAfter: number | null,
    path: string,
    signature: string,
    timestamp: number,
    workspace: string,
}
```
</details>

Represents some cryptographically-signed user data. The contents of a `Doc` can only be changed via `StorageAsync`. A document cannot be moved from one commons to another.

## `Crypto`

<details>
<summary>Type declaration</summary>
```typescript
interface Crypto {
    sha256base32(input: string | Uint8Array): Base32String;
    generateAuthorKeypair(name: string): AuthorKeypair | ValidationError;
    sign(keypair: AuthorKeypair, msg: string | Uint8Array): Base32String | ValidationError;
    verify(authorAddress: AuthorAddress, sig: Base32String, msg: string | Uint8Array): boolean;
    checkAuthorKeypairIsValid(keypair: AuthorKeypair): true | ValidationError;
}
```
</details>

![](/api-images/crypto.jpg)

`Crypto` is used internally for signing and verifying documents using [ed25519](https://ed25519.cr.yp.to). In most cases, you will want to use it to generate new identity keypairs:

```typescript
const keypair = Crypto.generateAuthorKeypair("suzy");

console.log(keypair);
/*
  {
    "address":"@suzy.bv3cclqhvnbn4fwjur7u4nimm4cznbzigqyihlfwi6acck5b4q54q",
    "secret":"bxrishindifrczhm5riqd4mozx4o5htksqthd64yph4rlfs6ej53n"
  }
*/
```

## `setGlobalCryptoDriver`

Because ed25519 is not part of any JS standard library (or WebCrypto API), there are several third-party implementations, some of which are only available for certain runtimes.

To balance compatibility and performance, Earthstar uses [noble/ed25519](https://github.com/paulmillr/noble-ed25519) by default. This works in browsers, Deno, and Node.

Earthstar exports a `setGlobalCrypto` function to change this:

```typescript
import { setGlobalCryptoDriver, CryptoDriverChloride } from "earthstar";

setGlobalCryptoDriver(CryptoDriverChloride);
```

## `QueryFollower`

![](/api-images/queryfollower.jpg)

<details>
<summary>Type declaration</summary>
```typescript
interface IQueryFollower {
    storage: IStorageAsync;
    query: Query;
    bus: Simplebus<LiveQueryEvent>;
    state(): QueryFollowerState;
    hatch(): Promise<void>;
    close(): Promise<void>;
}
```

</details>

Listens to events from a `StorageAsync`, and if it matches the given query, sends an event to a [`SuperBus`](https://github.com/cinnamon-bun/superbus).

Here's a basic usage:

```typescript
const myMarkdownFollower = new QueryFollower(myStorage, {
  filter: {
    pathEndsWith: ".md",
  },
});

// Print every newly created / updated Markdown doc to the console
myJpgFollower.bus.on((event: LiveQueryEvent) => {
  if (event.kind === "success") {
    console.log("A markdown doc was updated or created!");
  }
});

// Start the follower.
myJpgFollower.hatch();
```

A `QueryFollower` must always be _hatched_ first. Hatching makes it catch up with all existing documents which match the query, after which it starts listening for new events.

When you're done with a `QueryFollower`, you should close it to stop callbacks from running:

```typescript
myJpgFollower.close();
```

## `StorageCache`

<details>
<summary>Type declaration</summary>

```typescript
interface StorageCache {
  getAllDocs(): Doc[];
  getLatestDocs(): Doc[];
  getAllDocsAtPath(path: Path): Doc[];
  getLatestDocAtPath(path: Path): Doc | undefined;
  queryDocs(query: Query): Doc[];

  // These methods remain asynchronous!
  set(keypair: AuthorKeypair, docToSet: DocToSet): Promise<IngestEvent>;
  overwriteAllDocsByAuthor(
    keypair: AuthorKeypair
  ): Promise<number | ValidationError>;

  // Subscribe to cache updates. Returns a fn to unsubscribe.
  onCacheUpdated(callback: () => void | (() => Promise<void>)): () => void;
}
```

</details>

![](/api-images/storagecache.jpg)

`StorageAsync` offers a strictly asynchronous interface to a commons' contents. Sometimes a synchronous API would make life far easier, and `StorageCache` does its best to provide that.

`StorageCache` offers a synchronous API for fetching documents by storing queried documents in an internal cache.

When you first query a document, there is no result. But StorageCache can be subscribed to for updates, at which point you return to the cache and get an instant result:

```typescript
import { StorageCache } from "earthstar";

const cache = new StorageCache(myStorage);

const myQuery = { filter: { pathStartsWith: "/about/" } };

let aboutDocs = cache.queryDocs(myQuery); // This will be an empty list.

cache.onCacheUpdated(() => {
  // Trigger a re-querying of the cache!
  aboutDocs = cache.queryDocs(myQuery); // Now there should be something in there.
});
```

`StorageCache` has an optional TTL (time-to-live) option which can be provided to its constructor:

```typescript
const cache = new StorageCache(myStorage, 2000); // ms, 1000 by default
```

When you fetch an expired result from the cache, StorageCache will then return the latest result from its backing storage.
